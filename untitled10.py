# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i6xyG8bJn6l1f-g54OgK9eA-T9meD1jf
"""

!pip install accelerate==0.21.0 transformers==4.31.0 tokenizers==0.13.3
!pip install bitsandbytes==0.40.0 einops==0.6.1
!pip install xformers==0.0.22.post7
!pip install langchain==0.1.4
!pip install faiss-gpu==1.7.1.post3
!pip install sentence_transformers

pip install accelerate

nvidia-smi

from torch import cuda, bfloat16
import transformers
from transformers import AutoModelForCausalLM

model_id = 'bigscience/bloom-7b1'

device = f'cuda:{cuda.current_device()}' if cuda.is_available() else 'cpu'

# set quantization configuration to load large model with less GPU memory
# this requires the `bitsandbytes` library
bnb_config = transformers.BitsAndBytesConfig(
    load_in_4bit=True,
    bnb_4bit_quant_type='nf4',
    bnb_4bit_use_double_quant=True,
    bnb_4bit_compute_dtype=bfloat16
)

# begin initializing HF items, you need an access token
hf_auth = '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'
model_config = transformers.AutoConfig.from_pretrained(
    model_id,
    use_auth_token=hf_auth
)

model = transformers.AutoModelForCausalLM.from_pretrained(
    model_id,
    trust_remote_code=True,
    config=model_config,
    quantization_config=bnb_config,
    device_map='auto',
    use_auth_token=hf_auth
)

# enable evaluation mode to allow model inference
model.eval()

print(f"Model loaded on {device}")

tokenizer = transformers.AutoTokenizer.from_pretrained(
    model_id,
    use_auth_token=hf_auth
)

stop_list = ['\nHuman:', '\n```\n']

stop_token_ids = [tokenizer(x)['input_ids'] for x in stop_list]
stop_token_ids

import torch

stop_token_ids = [torch.LongTensor(x).to(device) for x in stop_token_ids]
stop_token_ids

from transformers import StoppingCriteria, StoppingCriteriaList,pipeline

# define custom stopping criteria object
class StopOnTokens(StoppingCriteria):
    def __call__(self, input_ids: torch.LongTensor, scores: torch.FloatTensor, **kwargs) -> bool:
        for stop_ids in stop_token_ids:
            if torch.eq(input_ids[0][-len(stop_ids):], stop_ids).all():
                return True
        return False

stopping_criteria = StoppingCriteriaList([StopOnTokens()])

generate_text = transformers.pipeline(
    model=model,
    tokenizer=tokenizer,#  These are specifying the pretrained transformer model and associated tokenizer to use for text generation.
    return_full_text=True,  # langchain expects the full text
    task='text-generation',
    # we pass model parameters here too
    stopping_criteria=stopping_criteria,  # without this model rambles during chat
    temperature=0.1,  #  Controls randomness of the generated text. Lower values make it more deterministic.
    max_new_tokens=1024,  # max number of tokens to generate in the output
    repetition_penalty=1.1  # without this output begins repeating
)

generate_text = pipeline(
    model=model,
    tokenizer=tokenizer,
    return_full_text=True,
    task='text-generation',
    stopping_criteria=stopping_criteria,
    temperature=0.7,  #  for more creative generation
    max_new_tokens=1500,
    # min_new_tokens=1000,
    repetition_penalty=1.2  # reduce repetition
)

pip install --upgrade langchain

pip install langchain_community

from langchain.prompts import PromptTemplate
from langchain.llms import HuggingFacePipeline
llm = HuggingFacePipeline(pipeline=generate_text)

template = """The Lester Dent Pulp Paper Master Fiction Plot Formula is a writing guide created by Lester Dent, a prolific pulp fiction writer best known for his work on the "Doc Savage" series. Dent's formula provides a structured approach to crafting engaging and action-packed stories. Here is a brief overview of the formula:

Introduction:

Introduce the hero and the central problem or conflict.
Set up a situation that hooks the reader's interest immediately.
First Quarter:

The hero tries to solve the problem.
Introduce complications and obstacles that thwart the hero's initial attempts.
Introduce other key characters (both allies and antagonists).
End with a twist or a surprising development.
Second Quarter:

Escalate the conflict and introduce additional problems for the hero.
The hero faces greater challenges and setbacks.
Include physical conflicts or action scenes.
Introduce a major plot twist or revelation that complicates the hero's mission.
Third Quarter:

The hero makes some progress towards solving the problem but faces significant adversity.
Introduce new conflicts and obstacles.
The hero encounters the main villain or a critical turning point in the story.
End with a twist that puts the hero in an even worse situation.
Final Quarter:

The hero faces the greatest challenges and is pushed to their limits.
All mysteries and plot threads are resolved.
The hero uses their skills, intelligence, and bravery to overcome the final obstacles.
End with a final twist or surprise that concludes the story in a satisfying way.





Characters:
- Hero: Emma Carter, a fearless archaeologist with a knack for solving ancient mysteries.
- Villain: Victor Steele, a ruthless treasure hunter obsessed with finding the legendary Elixir of Immortality.
- Sidekick: Raj Patel, a tech-savvy historian assisting Emma.
- Victim: Dr. Elena Gomez, a renowned historian murdered while researching the Elixir.
- Witness: Alex Turner, a local guide who witnessed the crime.

You are a story generator that follows the Lester Dent Pulp Paper formula.
Based on this formula, your task is to generate exactly the first 1500 words of the story in one continuous block of text. The text should be coherent, engaging, and flow like a real story without any interruptions or section headers.
"""
prompt = PromptTemplate.from_template(template)

# Generate the initial story outline
initial_result = llm(prompt.format())
print(initial_result)

from langchain.prompts import PromptTemplate
from langchain.llms import HuggingFacePipeline
llm = HuggingFacePipeline(pipeline=generate_text)

template = """
You are a story generator that follows the Lester Dent Pulp Paper formula.
The formula is as follows:

There are 4 steps, and we want just the first one for now.
FIRST 1500 WORDS
1. Introduce the hero and her problem.
2. Hero attempts to solve the problem.
3. Introduce other characters.
4. Hero faces physical conflict.
5. End with a surprise twist.

Characters:
- Hero: Emma Carter, a fearless archaeologist with a knack for solving ancient mysteries.
- Villain: Victor Steele, a ruthless treasure hunter obsessed with finding the legendary Elixir of Immortality.
- Sidekick: Raj Patel, a tech-savvy historian assisting Emma.
- Victim: Dr. Elena Gomez, a renowned historian murdered while researching the Elixir.
- Witness: Alex Turner, a local guide who witnessed the crime.

Based on this formula, generate exactly the first 1500 words of the story in one continuous block of text. The text should be coherent, engaging, and flow like a real story without any interruptions or section headers.
"""

prompt = PromptTemplate.from_template(template)

# Generate the initial story outline
initial_result = llm(prompt.format())
print(initial_result)

from langchain.llms import HuggingFacePipeline
from langchain.prompts import PromptTemplate

llm = HuggingFacePipeline(pipeline=generate_text)

template = """
You are a story generator that follows the Lester Dent Pulp Paper formula.
The formula is as follows:

This is a formula, a master plot, for any 6000 word pulp story. It has worked on adventure, detective, western and war-air. It tells exactly where to put everything. It shows definitely just what must happen in each successive thousand words.



No yarn of mine written to the formula has yet failed to sell.



The business of building stories seems not much different from the business of building anything else.



Here's how it starts:



1. A DIFFERENT MURDER METHOD FOR VILLAIN TO USE

2. A DIFFERENT THING FOR VILLAIN TO BE SEEKING

3. A DIFFERENT LOCALE

4. A MENACE WHICH IS TO HANG LIKE A CLOUD OVER HERO



One of these DIFFERENT things would be nice, two better, three swell. It may help if they are fully in mind before tackling the rest.



A different murder method could be--different. Thinking of shooting, knifing, hydrocyanic, garroting, poison needles, scorpions, a few others, and writing them on paper gets them where they may suggest something. Scorpions and their poison bite? Maybe mosquitos or flies treated with deadly germs?



If the victims are killed by ordinary methods, but found under strange and identical circumstances each time, it might serve, the reader of course not knowing until the end, that the method of murder is ordinary. Scribes who have their villain's victims found with butterflies, spiders or bats stamped on them could conceivably be flirting with this gag.



Probably it won't do a lot of good to be too odd, fanciful or grotesque with murder methods.



The different thing for the villain to be after might be something other than jewels, the stolen bank loot, the pearls, or some other old ones.



Here, again one might get too bizarre.



Unique locale? Easy. Selecting one that fits in with the murder method and the treasure--thing that villain wants--makes it simpler, and it's also nice to use a familiar one, a place where you've lived or worked. So many pulpateers don't. It sometimes saves embarrassment to know nearly as much about the locale as the editor, or enough to fool him.



Here's a nifty much used in faking local color. For a story laid in Egypt, say, author finds a book titled "Conversational Egyptian Easily Learned," or something like that.  He wants a character to ask in Egyptian, "What's the matter?" He looks in the book and finds, "El khabar, eyh?" To keep the reader from getting dizzy, it's perhaps wise to make it clear in some fashion, just what that means. Occasionally the text will tell this, or someone can repeat it in English. But it's a doubtful move to stop and tell the reader in so many words the English translation.



The writer learns they have palm trees in Egypt. He looks in the book, finds the Egyptian for palm trees, and uses that. This kids editors and readers into thinking he knows something about Egypt.



Here's the second installment of the master plot.



Divide the 6000 word yarn into four 1500 word parts. In each 1500 word part, put the following:





FIRST 1500 WORDS



1--First line, or as near thereto as possible, introduce the hero and swat him with a fistful of trouble. Hint at a mystery, a menace or a problem to be solved--something the hero has to cope with.



2--The hero pitches in to cope with his fistful of trouble. (He tries to fathom the mystery, defeat the menace, or solve the problem.)



3--Introduce ALL the other characters as soon as possible. Bring them on in action.



4--Hero's endevours land him in an actual physical conflict near the end of the first 1500 words.



5--Near the end of first 1500 words, there is a complete surprise twist in the plot development.



SO FAR: Does it have SUSPENSE?

Is there a MENACE to the hero?

Does everything happen logically?



At this point, it might help to recall that action should do something besides advance the hero over the scenery. Suppose the hero has learned the dastards of villains have seized somebody named Eloise, who can explain the secret of what is behind all these sinister events. The hero corners villains, they fight, and villains get away. Not so hot.



Hero should accomplish something with his tearing around, if only to rescue Eloise, and surprise! Eloise is a ring-tailed monkey. The hero counts the rings on Eloise's tail, if nothing better comes to mind. They're not real. The rings are painted there. Why?

characters:
Hero: Emma Carter, a fearless archaeologist with a knack for solving ancient mysteries.
Villain: Victor Steele, a ruthless treasure hunter obsessed with finding the legendary Elixir of Immortality.
Sidekick: Raj Patel, a tech-savvy historian assisting Emma.
Victim: Dr. Elena Gomez, a renowned historian murdered while researching the Elixir.
Witness: Alex Turner, a local guide who witnessed the crime.

Based on this formula, can you write the first 1500 words of the story?

"""

prompt = PromptTemplate.from_template(template)

# Generate the initial story outline
initial_result = llm(prompt.format())
print(initial_result)

from langchain_community.llms.huggingface_pipeline import HuggingFacePipeline
from langchain.prompts import PromptTemplate

llm = HuggingFacePipeline(pipeline=generate_text)

template = """
The Lester Dent Pulp Paper
Master Fiction Plot
Excerpted from Marilyn Cannaday's biography of Lester Dent,
"Bigger than Life: the Creator of Doc Savage" (Bowling Green State
University Popular Press, c1990), transcribed by Jason A. Wolcott, 1995.
This is a formula, a master plot, for any 6000 word pulp story. It has worked on adventure, detective, western and war-air. It tells exactly where to put everything. It shows definitely just what must happen in each successive thousand words.
No yarn of mine written to the formula has yet failed to sell.
The business of building stories seems not much different from the business of building anything else.
Here's how it starts:
1. A DIFFERENT MURDER METHOD FOR VILLAIN TO USE

2. A DIFFERENT THING FOR VILLAIN TO BE SEEKING

3. A DIFFERENT LOCALE

4. A MENACE WHICH IS TO HANG LIKE A CLOUD OVER HERO
One of these DIFFERENT things would be nice, two better, three swell. It may help if they are fully in mind before tackling the rest.
A different murder method could be--different. Thinking of shooting, knifing, hydrocyanic, garroting, poison needles, scorpions, a few others, and writing them on paper gets them where they may suggest something. Scorpions and their poison bite? Maybe mosquitos or flies treated with deadly germs?
If the victims are killed by ordinary methods, but found under strange and identical circumstances each time, it might serve, the reader of course not knowing until the end, that the method of murder is ordinary. Scribes who have their villain's victims found with butterflies, spiders or bats stamped on them could conceivably be flirting with this gag.
Probably it won't do a lot of good to be too odd, fanciful or grotesque with murder methods.
The different thing for the villain to be after might be something other than jewels, the stolen bank loot, the pearls, or some other old ones.
Here, again one might get too bizarre.
Unique locale? Easy. Selecting one that fits in with the murder method and the treasure--thing that villain wants--makes it simpler, and it's also nice to use a familiar one, a place where you've lived or worked. So many pulpateers don't. It sometimes saves embarrassment to know nearly as much about the locale as the editor, or enough to fool him.
Here's a nifty much used in faking local color. For a story laid in Egypt, say, author finds a book titled "Conversational Egyptian Easily Learned," or something like that.  He wants a character to ask in Egyptian, "What's the matter?" He looks in the book and finds, "El khabar, eyh?" To keep the reader from getting dizzy, it's perhaps wise to make it clear in some fashion, just what that means. Occasionally the text will tell this, or someone can repeat it in English. But it's a doubtful move to stop and tell the reader in so many words the English translation.
The writer learns they have palm trees in Egypt. He looks in the book, finds the Egyptian for palm trees, and uses that. This kids editors and readers into thinking he knows something about Egypt.
Here's the second installment of the master plot.
Divide the 6000 word yarn into four 1500 word parts. In each 1500 word part, put the following:

FIRST 1500 WORDS



1--First line, or as near thereto as possible, introduce the hero and swat him with a fistful of trouble. Hint at a mystery, a menace or a problem to be solved--something the hero has to cope with.
2--The hero pitches in to cope with his fistful of trouble. (He tries to fathom the mystery, defeat the menace, or solve the problem.)
3--Introduce ALL the other characters as soon as possible. Bring them on in action.
4--Hero's endevours land him in an actual physical conflict near the end of the first 1500 words.
5--Near the end of first 1500 words, there is a complete surprise twist in the plot development.



SO FAR: Does it have SUSPENSE?

Is there a MENACE to the hero?

Does everything happen logically?



At this point, it might help to recall that action should do something besides advance the hero over the scenery. Suppose the hero has learned the dastards of villains have seized somebody named Eloise, who can explain the secret of what is behind all these sinister events. The hero corners villains, they fight, and villains get away. Not so hot.



Hero should accomplish something with his tearing around, if only to rescue Eloise, and surprise! Eloise is a ring-tailed monkey. The hero counts the rings on Eloise's tail, if nothing better comes to mind. They're not real. The rings are painted there. Why?


You are a story generator that follows the Lester Dent Pulp Paper formula.
Based on this formula, can you write the first 1500 words of the story?
"""

prompt = PromptTemplate.from_template(template)

chain = prompt | llm

question = "write the first 1500 words of the story based on The Lester Dent Pulp Paper?"
print(chain.invoke({"question": question}))

# Integrate with LangChain


# Define the initial prompt
initial_prompt = """
You are a story generator that follows the Lester Dent Pulp Paper formula.
The formula is as follows:
1. A DIFFERENT MURDER METHOD FOR VILLAIN TO USE
2. A DIFFERENT THING FOR VILLAIN TO BE SEEKING
3. A DIFFERENT LOCALE
4. A MENACE WHICH IS TO HANG LIKE A CLOUD OVER HERO

Each 1500-word segment should follow this structure:
FIRST 1500 WORDS
1. Introduce the hero and his problem.
2. Hero attempts to solve the problem.
3. Introduce other characters.
4. Hero faces physical conflict.
5. End with a surprise twist.

SECOND 1500 WORDS
1. Add more trouble for the hero.
2. Hero struggles.
3. Another physical conflict.
4. Another plot twist.

THIRD 1500 WORDS
1. More trouble for the hero.
2. Hero makes some progress and faces a villain.
3. Physical conflict.
4. End with a twist, hero gets in worse trouble.

FOURTH 1500 WORDS
1. Hero faces maximum difficulties.
2. Hero almost buried in troubles.
3. Hero extricates himself using his skills.
4. Mysteries are solved.
5. End with a final twist.

Based on this formula, can you write the first 1500 words of the story?
"""

# Generate the initial story outline
initial_result = generate_text(initial_prompt)
print(initial_result[0]['generated_text'])

instructions = """
You are a story generator that follows the Lester Dent Pulp Paper formula.
The formula is as follows:
1. A DIFFERENT MURDER METHOD FOR VILLAIN TO USE
2. A DIFFERENT THING FOR VILLAIN TO BE SEEKING
3. A DIFFERENT LOCALE
4. A MENACE WHICH IS TO HANG LIKE A CLOUD OVER HERO

Each 1500-word segment should follow this structure:
FIRST 1500 WORDS
1. Introduce the hero and his problem.
2. Hero attempts to solve the problem.
3. Introduce other characters.
4. Hero faces physical conflict.
5. End with a surprise twist.

SECOND 1500 WORDS
1. Add more trouble for the hero.
2. Hero struggles.
3. Another physical conflict.
4. Another plot twist.

THIRD 1500 WORDS
1. More trouble for the hero.
2. Hero makes some progress and faces a villain.
3. Physical conflict.
4. End with a twist, hero gets in worse trouble.

FOURTH 1500 WORDS
1. Hero faces maximum difficulties.
2. Hero almost buried in troubles.
3. Hero extricates himself using his skills.
4. Mysteries are solved.
5. End with a final twist.

Generate a story outline based on this formula.
"""

initial_result = generate_text(instructions)
print(initial_result[0]['generated_text'])
# Define a follow-up question based on the initial result
follow_up_prompt = """
Based on the generated outline, can you write the first 1500 words of the story?
"""

# Generate the follow-up result
follow_up_result = llm(follow_up_prompt)
print(follow_up_result)

follow_up_question = """
Based on the generated outline, can you write the first 1500 words of the story?
"""

# Generate response to the follow-up question
follow_up_result = generate_text(follow_up_question)
print(follow_up_result[0]['generated_text'])

prompt = "This is the beginning of a thrilling adventure where the hero encounters a mysterious stranger."

# Generate text
result = generate_text(prompt)
print(result[0]['generated_text'])

from langchain.llms import HuggingFacePipeline

llm = HuggingFacePipeline(pipeline=generate_text)
llm(prompt="Explain me the difference between Data Lakehouse and Data Warehouse.")

pip install pypdf

from langchain.document_loaders import PyPDFLoader, DirectoryLoader

# Charger les documents du PDF
pdf_loader=DirectoryLoader('sample_data/',
                       glob="*.pdf",
                       loader_cls=PyPDFLoader)
documents = pdf_loader.load()

from langchain.document_loaders import PyPDFLoader, DirectoryLoader
loader=DirectoryLoader('sample_data/',
                       glob="*.pdf",
                       loader_cls=PyPDFLoader)

documents=loader.load()

from langchain.text_splitter import RecursiveCharacterTextSplitter

text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=20)
all_splits = text_splitter.split_documents(documents)

from langchain.embeddings import HuggingFaceEmbeddings
from langchain.vectorstores import FAISS

model_name = "sentence-transformers/all-mpnet-base-v2"
model_kwargs = {"device": "cuda"}

embeddings = HuggingFaceEmbeddings(model_name=model_name, model_kwargs=model_kwargs)

# storing embeddings in the vector store
vectorstore = FAISS.from_documents(all_splits, embeddings)

from langchain.chains import RetrievalQA
chain = RetrievalQA.from_chain_type(llm=llm,
                                    chain_type='stuff',
                                    retriever=vectorstore.as_retriever(search_kwargs={'k': 2}),
                                    return_source_documents=True,
                                   )

chat_history = []

while True:
    user_input = input(f"Prompt: ")

    if user_input.lower() == 'exit':
        print('Exiting')
        break

    if user_input == '':
        continue

    result = chain({'query': user_input, "chat_history": chat_history})

    if 'result' in result:
        print(f"Answer: {result['result']}")
        chat_history.append((user_input, result["result"]))
    else:
        print("No 'result' key found in the response.")